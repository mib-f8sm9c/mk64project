<!DOCTYPE html>
<!-- very crappy mesh viewer built off of three.js's cube example -->
<html lang="en">
	<head>
		<title>three.js webgl - geometry - cube</title>
		<meta charset="utf-8">
		<style>
			body {
				margin: 0px;
				background-color: #000000;
				overflow: hidden;
			}
		</style>
	</head>
	<body>
		<div><input type="file" id="meshfile"></div>
		
		<script src="three.min.js"></script>
		<script src="Projector.js"></script>
		<script src="CanvasRenderer.js"></script>
		
		<script>
			// mesh file loader:
			var meshdata;
			var fileInput = document.getElementById("meshfile");
			var reader = new FileReader();
			reader.onloadend = function(){
				meshdata = new Int16Array(this.result);
				for(var i = 0; i < meshdata.length; i++){
					meshdata[i] = ((meshdata[i] & 0xFF00) >> 8) | ((meshdata[i] & 0x00FF) << 8);
				}
				init();
				animate();
			}
			fileInput.onchange = function(){
				reader.readAsArrayBuffer(fileInput.files[0]);

			}
		
			// threejs:
			var camera, scene, renderer;
			var mesh;



			function init() {

				renderer = new THREE.CanvasRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				//

				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 6000 );
				camera.position.z = 2000;
				camera.position.x = -1000;

				scene = new THREE.Scene();

				var geometry = new THREE.BufferGeometry();
				
				var vertexPositions = [];
				for(var i = 0; i < meshdata.length; i += 7){
					vertexPositions.push([meshdata[i+0], meshdata[i+1], meshdata[i+2]]);
				}
				
				var vertices = new Float32Array( vertexPositions.length * 3 )
				
				for ( var i = 0; i < vertexPositions.length; i++ )
				{
					vertices[ i*3 + 0 ] = vertexPositions[i][0];
					vertices[ i*3 + 1 ] = vertexPositions[i][1];
					vertices[ i*3 + 2 ] = vertexPositions[i][2];
				}

				geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
				var col = 0x00FFFF;
				var material = new THREE.MeshBasicMaterial( { color: col, wireframe: true} );
				mesh = new THREE.Mesh( geometry, material );

				mesh.scale = {x: 0.1, y: 0.1, z: 0.1};
				scene.add( mesh );

				window.addEventListener( 'resize', onWindowResize, false );

			}
			var KEY_DOWN  = 40;
			var KEY_UP    = 38;
			var KEY_LEFT  = 37;
			var KEY_RIGHT = 39;
			
			var keysdown = [];
			
			document.body.onkeydown = function(e){
				keysdown[e.keyCode] = true;
			}
			document.body.onkeyup = function(e){
				delete keysdown[e.keyCode];
			}
			function isPressed(keyCode){
				return keyCode in keysdown;
			}
			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}
			function animate() {

				requestAnimationFrame( animate );
				switch(true){
					case isPressed(KEY_UP):   camera.position.y++; break;
					case isPressed(KEY_DOWN): camera.position.y--; break;
				}
				
				mesh.rotation.x -= 0.001;
				mesh.rotation.y += 0.001;

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>
