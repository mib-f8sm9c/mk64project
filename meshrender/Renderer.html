<!DOCTYPE html>
<!-- very crappy mesh viewer built off of three.js's cube example -->
<html lang="en">
	<head>
		<title>Course viewer</title>
		<meta charset="utf-8">
		<style>
			body {
				margin: 0px;
				background-color: #000000;
				overflow: hidden;
				color: #fff;
				font: 10px tahoma;
			}
			input, select, option {
				font: 10px tahoma;
			}
		</style>
	</head>
	<body>
		<div style="position:absolute;">
		<div style="display:inline-block;border:1px solid #444;padding:3px;">
			course mesh (seg 04)<br>
			<input type="file" id="meshfile">
		</div>
		<div style="display:inline-block;border:1px solid #444;padding:3px;">
			course path (seg 06)<br>
			<select id="path-offset">
				<option>060057B0 Mario raceway</option>
			</select><input type="file" id="pathfile">
		</div>
		</div>
		<script src="three.min.js"></script>

		<script>
			function BinInput(fileElement, callback){
				if(typeof(fileElement) == "string"){
					fileElement = document.getElementById(fileElement);
				}
				var reader = new FileReader();
				reader.onloadend = function(){
					callback(this.result);
				}
				fileElement.onchange = function(){
					reader.readAsArrayBuffer(this.files[0]);
				}
				this.fileElement = fileElement;
				this.callback    = callback;
			}
			// mesh file loader:
			var meshdata;
			var MESHSCALE = 2;
			BinInput("meshfile", function(result){
				meshdata = new Int16Array(result);
				for(var i = 0; i < meshdata.length; i++){
					meshdata[i] = ((meshdata[i] & 0xFF00) >> 8) | ((meshdata[i] & 0x00FF) << 8);
				}
				courseMesh();
			});
			
			BinInput("pathfile", function(result){
				meshdata = new Int16Array(result);
				for(var i = 0; i < meshdata.length; i++){
					meshdata[i] = ((meshdata[i] & 0xFF00) >> 8) | ((meshdata[i] & 0x00FF) << 8);
				}
				coursePath();
			});

			// threejs:
			var camera, scene, renderer;
			var meshes = [];

			function init() {
				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 6000);
				camera.position.z = 2000;
				camera.position.x = -1000;

				scene = new THREE.Scene();

				window.addEventListener( 'resize', onWindowResize, false );
			}
			
			function courseMesh(){
				var geometry = new THREE.BufferGeometry();
				var vertexPositions = [];
				for(var i = 0; i < meshdata.length; i += 7){
					vertexPositions.push([meshdata[i+0], meshdata[i+1], meshdata[i+2]]);
				}
				
				var vertices = new Float32Array(vertexPositions.length * 3);
				
				for (var i = 0; i < vertexPositions.length; i++){
					vertices[i*3 + 0] = vertexPositions[i][0];
					vertices[i*3 + 1] = vertexPositions[i][1];
					vertices[i*3 + 2] = vertexPositions[i][2];
				}

				geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
				var col = 0x666666;
				var material = new THREE.MeshBasicMaterial( { color: col, wireframe: true} );
				mesh = new THREE.Mesh( geometry, material );

				mesh.scale = {x: MESHSCALE, y: MESHSCALE, z: MESHSCALE};
				scene.add(mesh);
				meshes.push(mesh);
				//mesh.rotation.x = Math.PI/4;
				mesh.position.x = -1500;
			}
			
			function ItemBoxMesh(){
				var geometry = new THREE.BoxGeometry(10, 10, 10); //new THREE.BufferGeometry();
				//geometry.addAttribute('position', new THREE.BufferAttribute(verts, 3));
				var col = 0xFF0000;
				var material = new THREE.MeshBasicMaterial( { color: col, wireframe: true} );
				var mesh = new THREE.Mesh(geometry, material);
				mesh.scale = {x: MESHSCALE, y: MESHSCALE, z: MESHSCALE};
				return mesh;
			}
			
			function UnkMesh(){
				var geometry = new THREE.BoxGeometry(10, 10, 10); //new THREE.BufferGeometry();
				//geometry.addAttribute('position', new THREE.BufferAttribute(verts, 3));
				var col = 0xFF00FF;
				var material = new THREE.MeshBasicMaterial( { color: col, wireframe: true} );
				var mesh = new THREE.Mesh(geometry, material);
				mesh.scale = {x: MESHSCALE, y: MESHSCALE, z: MESHSCALE};
				return mesh;
			}
			
			function UnkMesh2(){
				var geometry = new THREE.BoxGeometry(10, 40, 10); //new THREE.BufferGeometry();
				//geometry.addAttribute('position', new THREE.BufferAttribute(verts, 3));
				var col = 0xAAFF00;
				var material = new THREE.MeshBasicMaterial( { color: col, wireframe: true} );
				var mesh = new THREE.Mesh(geometry, material);
				mesh.scale = {x: MESHSCALE, y: MESHSCALE, z: MESHSCALE};
				return mesh;
			}
			
			function coursePath(){
				var geometry = new THREE.BufferGeometry();
				
				var vertexPositions = [];
				for(var i = 0x57B0/2; i < 0x57B0/2 + 0xF98/2; i += 4){ // detailed path
					vertexPositions.push([meshdata[i+0], meshdata[i+1], meshdata[i+2]]);
				}
				
				var vertices = new Float32Array( vertexPositions.length * 3)
				
				for(var i = 0; i < vertexPositions.length; i++){
					vertices[i*3 + 0] = vertexPositions[i][0];
					vertices[i*3 + 1] = vertexPositions[i][1];
					vertices[i*3 + 2] = vertexPositions[i][2];
				}

				geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
				var col = 0x00FF00;
				var material = new THREE.MeshBasicMaterial( { color: col, wireframe: true} );
				mesh = new THREE.Mesh( geometry, material );

				mesh.scale = {x: MESHSCALE, y: MESHSCALE, z: MESHSCALE};
				scene.add(mesh);
				meshes.push(mesh);
				//mesh.rotation.x = Math.PI/4;
				//mesh.rotation.y = -Math.PI/6
				mesh.position.x = -1500;
				
				
				geometry = new THREE.BufferGeometry();
				
				vertexPositions = [];
				for(var i = 0x5568/2; i < 0x5568/2 + 0x248/2; i += 4){// simple path
					vertexPositions.push([meshdata[i+0], meshdata[i+1], meshdata[i+2]]);
				}
				
				var vertices = new Float32Array( vertexPositions.length * 3)
				
				for(var i = 0; i < vertexPositions.length; i++){
					vertices[i*3 + 0] = vertexPositions[i][0];
					vertices[i*3 + 1] = vertexPositions[i][1];
					vertices[i*3 + 2] = vertexPositions[i][2];
				}

				geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
				col = 0xFFFF00;
				material = new THREE.MeshBasicMaterial( { color: col, wireframe: true} );
				mesh = new THREE.Mesh( geometry, material );

				mesh.scale = {x: MESHSCALE, y: MESHSCALE, z: MESHSCALE};
				scene.add(mesh);
				meshes.push(mesh);
				//mesh.rotation.x = Math.PI/4;
				//mesh.rotation.y = -Math.PI/6
				mesh.position.x = -1500;
				
				for(var i = 0x9498/2; i < 0x9510/2; i+=4){
					console.log(meshdata[i + 0])
					var box = new ItemBoxMesh();
					scene.add(box);
					meshes.push(box);
					box.position.x = -1500 + meshdata[i + 0];
					box.position.y = meshdata[i + 1];
					box.position.z = meshdata[i + 2];
				}
				
				for(var i = 0x9518/2; i < 0x9568/2; i+= 4){
					console.log(meshdata[i + 0])
					var box = new UnkMesh();
					scene.add(box);
					meshes.push(box);
					box.position.x = -1500 + meshdata[i + 0];
					box.position.y = meshdata[i + 1];
					box.position.z = meshdata[i + 2];
				}
				
				for(var i = 0x9570/2; i < 0x9648/2; i+= 4){
					console.log(meshdata[i + 0])
					var box = new UnkMesh2();
					scene.add(box);
					meshes.push(box);
					box.position.x = -1500 + meshdata[i + 0];
					box.position.y = meshdata[i + 1];
					box.position.z = meshdata[i + 2];
				}
			}
			
			var vertexPositions = [];
			
			var KEY_DOWN  = 40;
			var KEY_UP    = 38;
			var KEY_LEFT  = 37;
			var KEY_RIGHT = 39;
			
			var keysdown = [];
			
			document.body.onkeydown = function(e){
				keysdown[e.keyCode] = true;
			}
			document.body.onkeyup = function(e){
				delete keysdown[e.keyCode];
			}
			function isPressed(keyCode){
				return keyCode in keysdown;
			}
			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight - 5 );

			}
			var phase = 0;
			function animate() {
				requestAnimationFrame( animate );
				switch(true){
					case isPressed(KEY_UP):   camera.position.y += 5; break;
					case isPressed(KEY_DOWN): camera.position.y -= 5; break;
				}
				for(var i in meshes){
					//meshes[i].rotation.x -= 0.0005;
				}
				if(scene.rotation.x > 1){
					phase = 1;
				} else if(scene.rotation.x < 0){
					phase = 0;
				}
				if(phase){
					scene.rotation.x -= 0.001;
				} else {
					scene.rotation.x += 0.001;
				}
				renderer.render( scene, camera );
			}
			init();
			animate();
		</script>
	</body>
</html>
