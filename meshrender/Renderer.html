<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Course viewer</title>
		<meta charset="utf-8">
		<style>
			body {
				margin: 0px;
				background-color: #111;
				overflow: hidden;
				color: #fff;
				font: 10px tahoma;
			}
			input, select, option {
				font: 10px tahoma;
			}
		</style>
	</head>
	<body>
		<div>
			<div style="display:inline-block;border:1px solid #444;padding:3px;">
				course mesh (seg 04)<br>
				<input type="file" id="meshfile">
			</div>
			<div style="display:inline-block;border:1px solid #444;padding:3px;">
				course path (seg 06)<br>
				<select id="path-offset">
					<option>060057B0 Mario raceway</option>
				</select>
				<input type="file" id="pathfile">
			</div>
		</div>
		<center id="container" style="padding:10px;"></center>
		<script src="three.min.js"></script>

		<script>
			function BinInput(fileElement, callback){
				if(typeof(fileElement) == "string"){
					fileElement = document.getElementById(fileElement);
				}
				var reader = new FileReader();
				reader.onloadend = function(){
					callback(this.result);
				}
				fileElement.onchange = function(){
					reader.readAsArrayBuffer(this.files[0]);
				}
				this.fileElement = fileElement;
				this.callback    = callback;
			}
			
			// file loaders:
			var s16data; // s16 array of last loaded file
			BinInput("meshfile", function(result){
				s16data = new Int16Array(result);
				for(var i = 0; i < s16data.length; i++){
					s16data[i] = ((s16data[i] & 0xFF00) >> 8) | ((s16data[i] & 0x00FF) << 8);
				}
				drawCourseGeometry();
			});
			BinInput("pathfile", function(result){
				s16data = new Int16Array(result);
				for(var i = 0; i < s16data.length; i++){
					s16data[i] = ((s16data[i] & 0xFF00) >> 8) | ((s16data[i] & 0x00FF) << 8);
				}
				drawSeg06();
			});

			// Mesh classes:
			function ItemBoxMesh(){
				var geometry = new THREE.BoxGeometry(10, 10, 10);
				var col = 0xFF0000;
				var material = new THREE.MeshBasicMaterial({color: col, wireframe: true});
				var mesh = new THREE.Mesh(geometry, material);
				return mesh;
			}
			function PirhanaPlantMesh(){
				var geometry = new THREE.BoxGeometry(10, 10, 10);
				var col = 0xFF00FF;
				var material = new THREE.MeshBasicMaterial({color: col, wireframe: true});
				var mesh = new THREE.Mesh(geometry, material);
				return mesh;
			}
			function TreeMesh(){
				var geometry = new THREE.BoxGeometry(10, 40, 10);
				var col = 0xAAFF00;
				var material = new THREE.MeshBasicMaterial({color: col, wireframe: true});
				var mesh = new THREE.Mesh(geometry, material);
				return mesh;
			}
			
			// threejs vars
			var camera, scene, renderer;
			var scenewidth = 960;
			var sceneheight = 640;
			
			// keep track of meshes
			var meshes = [];

			function init() { // initialise scene
				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(scenewidth, sceneheight);
				renderer.domElement.style.width = "960px";
				renderer.domElement.style.height = "640px";
				renderer.domElement.style.border = "1px solid #444";
				document.getElementById("container").appendChild(renderer.domElement);
				camera = new THREE.PerspectiveCamera(60, scenewidth/sceneheight, 1, 6000);
				camera.position.x = 1500;
				camera.position.y = 500;
				camera.position.z = 3000;
				scene = new THREE.Scene();
			}
			
			function addmesh(mesh, x, y, z){ // add mesh to scene with coordinated, save ref to meshes array
				mesh.position.x = x || 0;
				mesh.position.y = y || 0;
				mesh.position.z = z || 0;
				scene.add(mesh);
				meshes.push(mesh);
			}
			
			function drawCourseGeometry(){ // course mesh
				var geometry = new THREE.BufferGeometry();
				var vertexPositions = [];
				for(var i = 0; i < s16data.length; i += 7){
					vertexPositions.push([s16data[i+0], s16data[i+1], s16data[i+2]]);
				}
				var vertices = new Float32Array(vertexPositions.length * 3);
				for (var i = 0; i < vertexPositions.length; i++){
					vertices[i*3 + 0] = vertexPositions[i][0];
					vertices[i*3 + 1] = vertexPositions[i][1];
					vertices[i*3 + 2] = vertexPositions[i][2];
				}
				geometry.addAttribute('position', new THREE.BufferAttribute(vertices, 3));
				var col = 0x666666;
				var material = new THREE.MeshBasicMaterial( { color: col, wireframe: true} );
				addmesh(new THREE.Mesh(geometry, material));
			}
			
			function drawSeg06(){ // just path and object positions for now
				var LIST_END = -0x8000; // position lists end when an X coordinate is 0x8000 apparently
				
				// detailed path:
				var geometry = new THREE.BufferGeometry();
				var vertexPositions = [];
				for(var i = 0x57B0/2; s16data[i] ^ LIST_END; i += 4){
					vertexPositions.push([s16data[i+0], s16data[i+1], s16data[i+2]]);
				}
				var vertices = new Float32Array(vertexPositions.length * 3);
				for(var i = 0; i < vertexPositions.length; i++){
					vertices[i*3 + 0] = vertexPositions[i][0];
					vertices[i*3 + 1] = vertexPositions[i][1];
					vertices[i*3 + 2] = vertexPositions[i][2];
				}
				geometry.addAttribute('position', new THREE.BufferAttribute(vertices, 3));
				var material = new THREE.MeshBasicMaterial({color: 0x00FF00, wireframe: true});
				addmesh(new THREE.Mesh(geometry, material));
				
				// simple path:
				geometry = new THREE.BufferGeometry();
				vertexPositions = [];
				for(var i = 0x5568/2; s16data[i] ^ LIST_END; i += 4){
					vertexPositions.push([s16data[i+0], s16data[i+1], s16data[i+2]]);
				}
				var vertices = new Float32Array( vertexPositions.length * 3)
				for(var i = 0; i < vertexPositions.length; i++){
					vertices[i*3 + 0] = vertexPositions[i][0];
					vertices[i*3 + 1] = vertexPositions[i][1];
					vertices[i*3 + 2] = vertexPositions[i][2];
				}
				geometry.addAttribute('position', new THREE.BufferAttribute(vertices, 3));
				material = new THREE.MeshBasicMaterial({color: 0xFFFF00, wireframe: true});
				addmesh(new THREE.Mesh(geometry, material));
				
				// objects:
				for(var i = 0x9498/2; s16data[i] ^ LIST_END; i += 4){ // item boxes
					addmesh(new ItemBoxMesh(), s16data[i+0], s16data[i+1], s16data[i+2]);
				}
				for(var i = 0x9518/2; s16data[i] ^ LIST_END; i += 4){ // pirhana plants
					addmesh(new PirhanaPlantMesh(), s16data[i+0], s16data[i+1], s16data[i+2]);
				}
				for(var i = 0x9570/2; s16data[i] ^ LIST_END; i += 4){ // trees
					addmesh(new TreeMesh(), s16data[i+0], s16data[i+1], s16data[i+2]);
				}
			}

			var keyevents = {
				27: function(){ // esc - reset camera position
					with(camera.position){
						x = 1500;
						y = 500;
						z = 2500;
					}
					with(camera.rotation) x = y = z = 0;
				},
				87: function(){ camera.translateZ(-10); }, // w - move forward
				65: function(){ camera.translateX(-10); }, // a - pan left
				83: function(){ camera.translateZ( 10); }, // s - move backward
				68: function(){ camera.translateX( 10); }, // d - pan right
				90: function(){ camera.translateY(-10); }, // z - pan down
				88: function(){ camera.translateY( 10); }, // x - pan up
				40: function(){ camera.rotateX( -0.01); }, // down - rotate down
				38: function(){ camera.rotateX(  0.01); }, // up - rotate up
				37: function(){ camera.rotateY(  0.01); }, // left - rotate left
				39: function(){ camera.rotateY( -0.01); }  // right - rotate right
			};
			
			var keysdown = [];
			document.body.onkeydown = function(e){
				keysdown[e.keyCode] = true;
				//console.log(e);
			}
			document.body.onkeyup = function(e){
				delete keysdown[e.keyCode];
			}
			function animate(){
				requestAnimationFrame( animate );
				for(var i in keysdown){
					if(i in keyevents) keyevents[i]();
				}
				renderer.render(scene, camera);
			}
			init();
			animate();
		</script>
	</body>
</html>