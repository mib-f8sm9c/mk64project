<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Course viewer</title>
		<meta charset="utf-8">
		<style>
			body {
				margin: 0px;
				background-color: #111;
				overflow: hidden;
				color: #fff;
				font: 11px tahoma;
			}
			input, select, option {
				font: 11px tahoma;
			}
			.optionlist {
				vertical-align: top; overflow:auto; height: 250px; width: 150px; background-color: #000; border:1px solid #444; padding:4px;
				cursor: default;
			}
			.optionlist div {
				cursor: default;
			}
			.optionlist div:hover {
				background-color: #440;
			}
		</style>
	</head>
	<body>
		Rom file (Z64) <input type="file" id="romfile" value="">
		<center style="padding:10px;">
			<div style="display: inline-block; text-align:left;">
				<div style="display:inline-block; vertical-align:top;">
					<div style="background-color:#444;padding:4px;">Courses</div>
					<div id="coursemenu" class="optionlist"></div>
					<div style="background-color:#444;padding:4px;margin-top:4px">Objects</div>
					<div id="objects" class="optionlist"></div>
				</div>
				<div style="display:inline-block; vertical-align:top;">
					<div style="background-color:#444;padding:4px;" id="loadedname">(No course loaded)</div>
					<div id="container" style="display:inline-block;"></div>
					<canvas id="textures" width="960" height="128" style="background-color:#000;border:1px solid #444;display:block"></canvas>
				</div>
			</div>
		</center>
		<pre id="dbg"></pre>
		<script src="three.min.js"></script>
		<script src="shared.js"></script>
		<script>
			var tctx = document.getElementById("textures").getContext("2d");
			
			var coursemenu = document.getElementById("coursemenu");
			var loadedname = document.getElementById("loadedname");
			var dbg = document.getElementById("dbg");
			function log(s, nobr){
				dbg.innerHTML += s + (nobr ? "" : "\n"); 
			}

			var MAPNAMES = [
				"Mario Raceway      ", 
				"Choco Mountain     ",
				"Bowser's Castle    ",
				"Banshee Boardwalk  ",
				"Yoshi Valley       ",
				"Frappe Snowland    ",
				"Koopa Troopa Beach ",
				"Royal Raceway      ",
				"Luigi Raceway      ",
				"Moo Moo Farm       ",
				"Toad's Turnpike    ",
				"Kalimari Desert    ",
				"Sherbet Land       ",
				"Rainbow Road       ",
				"Wario Stadium      ",
				"Block Fort         ",
				"Skyscraper         ",
				"Double Deck        ",
				"DK's Jungle Parkway",
				"Big Donut          ",
			];
			
			var MAPSTRUCTS = 0x122390;
			var TEXTURES   = 0x641F70;
			
			var SEGMENT04;
			var SEGMENT06;
			
			var maps = [];
			
			var map_presets = {
				0x00: { // mario raceway
					path_u: [0x5568],
					path:   [0x57B0],
					items:  [0x9498],
					plants: [0x9518],
					trees:  [0x9570]
				},
				0x01: {  // choco
					path_u: [0x4480],
					path:   [0x47F0],
					items:  [0x7250]
				},
				0x02: {  // bowser
					path_u: [0x4F90],
					path:   [0x51D0],
					bushes: [0x9290],
					items:  [0x9370],
				},
				0x03: { // banshee boardwalk
					path_u: [0x4578],
					path:   [0x47F0],
					items:  [0xB3D0]
				},
				0x04: {  // yoshi 
					path_u: [0xD780, 0xD9C8, 0xDC18, 0xDEA8],
					path:   [0xE150, 0xF680, 0x10B58, 0x12090],
					trees:  [0x180A0],
					items:  [0x18110],
				},
				0x05: { // frappe snowland
					path:   [0x36E8],
					path_u: [0x34A0],
					trees:  [0x7718],
					items:  [0x7810],
				},
				0x06: { // koopa troopa beach
					path_u: [0xADE0],
					path:   [0xB1A8],
					items:  [0x18E78],
					trees:  [0x18F70],
				},
				0x07: {}, // 
				0x08: {}, // 
				0x09: {}, // 
				0x0A: {}, // 
				0x0B: {}, // 
				0x0C: {}, // 
				0x0D: {}, // 
				0x0E: {}, // 
				0x0F: {}, // 
				0x10: {}, // 
				0x11: {}, // 
				0x12: {}, // 
				0x13: {}, // 
			};
			
			var romdata;
			BinInput("romfile", function(result){
				romdata = new Uint8Array(result);
				for(var i = 0; i < 16; i++){
					var map = {
						ASSETS_START : getU32BE(romdata, MAPSTRUCTS + (i * 0x30) + 0x00),
						ASSETS_END   : getU32BE(romdata, MAPSTRUCTS + (i * 0x30) + 0x04),
						MESH_START   : getU32BE(romdata, MAPSTRUCTS + (i * 0x30) + 0x08),
						MESH_END     : getU32BE(romdata, MAPSTRUCTS + (i * 0x30) + 0x0C),
						REFS_START   : getU32BE(romdata, MAPSTRUCTS + (i * 0x30) + 0x10),
						REFS_END     : getU32BE(romdata, MAPSTRUCTS + (i * 0x30) + 0x14),
					}
					maps.push(map);
					var courselink = document.createElement("div");
					courselink.mapId = i;
					courselink.onclick = function(){drawMap(this.mapId);}
					courselink.appendChild(document.createTextNode(MAPNAMES[i]));
					coursemenu.appendChild(courselink);
				}
				drawMap(0);
			});
			
			// Mesh classes:
			function ItemBoxMesh(){
				//var t = new THREE.DataTexture(test_texturedata, 32, 32, THREE.RGBAFormat, THREE.UnsignedShort5551Type);
				//t.needsUpdate = true;
				return new THREE.Mesh(
					new THREE.BoxGeometry(10, 10, 10),
					new THREE.MeshBasicMaterial({color: 0xFF0000, wireframe: true}/*{map: t}*/)
				);
			}
			function PlantMesh(){
				return new THREE.Mesh(
					new THREE.BoxGeometry(15, 15, 15),
					new THREE.MeshBasicMaterial({color: 0xFF0000, wireframe: true})
				);
			}
			function TreeMesh(){
				return new THREE.Mesh(
					new THREE.BoxGeometry(10, 40, 10),
					new THREE.MeshBasicMaterial({color: 0xFF0000, wireframe: true})
				);
			}
			
			// threejs vars
			var camera, scene, renderer, mouse, raycaster;
			var camera_birdseye;
			var scenewidth = 960;
			var sceneheight = 640;
			
			// keep track of meshes
			var meshes = [];
			var mesh_selection;

			function init() { // initialise scene
				renderer = new THREE.WebGLRenderer();
				scene = new THREE.Scene();
				mouse = new THREE.Vector2();
				raycaster = new THREE.Raycaster();
				
				camera = new THREE.PerspectiveCamera(60, scenewidth/sceneheight, 1, 6000);
				camera.rotation.order = "YXZ";
				camera_birdseye = new THREE.PerspectiveCamera(60, scenewidth/sceneheight, 1, 6000);
				
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(scenewidth, sceneheight);
				renderer.enableScissorTest(true);
				renderer.domElement.style.width = "960px";
				renderer.domElement.style.height = "640px";
				renderer.domElement.style.border = "1px solid #444";
				document.getElementById("container").appendChild(renderer.domElement);
				
				camera.position.x = 1500;
				camera.position.y = 500;
				camera.position.z = 3000;
				
				camera_birdseye.position.x = 1300;
				camera_birdseye.position.y = 3000;
				camera_birdseye.position.z = 0;
				camera_birdseye.rotation.x = -(2 * (Math.PI) / 4);
				
				renderer.domElement.onmousemove = function(e){
					var rect = this.getBoundingClientRect();
					mouse.x = ((e.clientX - rect.x) / this.clientWidth ) * 2 - 1;
					mouse.y = -((e.clientY - rect.y) / this.clientHeight ) * 2 + 1;
				}
				renderer.domElement.onmousedown = function(e){
					e.preventDefault();
					raycaster.setFromCamera(mouse, camera);
					var intersects = raycaster.intersectObjects(scene.children); 
					if(intersects.length > 0 && meshes[intersects[0].object.identity][0] == "object") {
						mesh_selection = meshes[intersects[0].object.identity];
						console.log(meshes[intersects[0].object.identity]);
						for(var i = 0; i < meshes.length; i++){
							if(meshes[i][0] == "object"){
								meshes[i][2].material.color.g = 0;
							}
						}
						mesh_selection[2].material.color.g = 1;
						intersects[0].object.material.color.g = 1;
					}
				}
				renderer.domElement.onwheel = function(e){
					camera.translateZ(e.deltaY * 30);
				}
			}
			
			function addmesh(mesh, x, y, z, cat, tag){ // add mesh to scene with coordinates, save ref to meshes array
				mesh.position.x = x || 0;
				mesh.position.y = y || 0;
				mesh.position.z = z || 0;
				scene.add(mesh);
				mesh.identity = meshes.push([cat || "", tag || "", mesh]) - 1;
			}
			
			function drawCourseGeometry(segmentbuffer){ // course mesh
				var s16data = Uint8ToInt16ArrayBE(segmentbuffer);
				var geometry = new THREE.BufferGeometry();
				var vertexPositions = [];
				for(var i = 0; i < s16data.length; i += 7){
					vertexPositions.push([s16data[i+0], s16data[i+1], s16data[i+2]]);
				}
				var vertices = new Float32Array(vertexPositions.length * 3);
				for (var i = 0; i < vertexPositions.length; i++){
					vertices[i*3 + 0] = vertexPositions[i][0];
					vertices[i*3 + 1] = vertexPositions[i][1];
					vertices[i*3 + 2] = vertexPositions[i][2];
				}
				geometry.addAttribute('position', new THREE.BufferAttribute(vertices, 3));
				var material = new THREE.MeshBasicMaterial({color: 0x666666, wireframe: true});
				addmesh(new THREE.Mesh(geometry, material));
			}
			
			function drawSeg06(segmentbuffer, mapId){ // just path and object positions for now
				var s16data = Uint8ToInt16ArrayBE(segmentbuffer);
				var LIST_END = -0x8000; // position lists end when an X coordinate is 0x8000 apparently

				var path_u = map_presets[mapId].path_u || [];
				var path   = map_presets[mapId].path   || [];
				var items  = map_presets[mapId].items  || [];
				var plants = map_presets[mapId].plants || [];
				var trees  = map_presets[mapId].trees  || [];
				var bushes = map_presets[mapId].bushes || [];
				
				// detailed paths:
				pathcolors = [0x00FF00, 0xFF0000, 0xFFFF00, 0xFF00FF];
				pathcolor_i = 0;
				path.forEach(function(path_offset){
					var geometry = new THREE.BufferGeometry();
					var vertexPositions = [];
					for(var i = path_offset/2; s16data[i] ^ LIST_END; i += 4){
						vertexPositions.push([s16data[i+0], s16data[i+1], s16data[i+2]]);
					}
					var vertices = new Float32Array(vertexPositions.length * 3);
					for(var i = 0; i < vertexPositions.length; i++){
						vertices[i*3 + 0] = vertexPositions[i][0];
						vertices[i*3 + 1] = vertexPositions[i][1];
						vertices[i*3 + 2] = vertexPositions[i][2];
					}
					geometry.addAttribute('position', new THREE.BufferAttribute(vertices, 3));
					var col = (Math.random()*0x7FFFFF | 0) + 0x7FFFFF
					var material = new THREE.PointCloudMaterial({color: pathcolors[pathcolor_i], size: 1});
					addmesh(new THREE.PointCloud(geometry, material), 0, 0, 0, "data", "path");
					pathcolor_i = (pathcolor_i + 1) % 4;
				});
				
				// simple paths:
				path_ucolors = [0x006600, 0x660000, 0x666600, 0x660066];
				path_ucolor_i = 0;
				path_u.forEach(function(path_u_offset){
					geometry = new THREE.BufferGeometry();
					vertexPositions = [];
					for(var i = path_u_offset/2; s16data[i] ^ LIST_END; i += 4){
						vertexPositions.push([s16data[i+0], s16data[i+1], s16data[i+2]]);
					}
					var vertices = new Float32Array( vertexPositions.length * 3)
					for(var i = 0; i < vertexPositions.length; i++){
						vertices[i*3 + 0] = vertexPositions[i][0];
						vertices[i*3 + 1] = vertexPositions[i][1];
						vertices[i*3 + 2] = vertexPositions[i][2];
					}
					geometry.addAttribute('position', new THREE.BufferAttribute(vertices, 3));
					material = new THREE.PointCloudMaterial({color: path_ucolors[path_ucolor_i], size: 10});
					addmesh(new THREE.PointCloud(geometry, material), 0, 0, 0, "data", "path_u");
					path_ucolor_i = (path_ucolor_i + 1) % 4;
				});
				
				// objects:
				items.forEach(function(items_offset){ // item boxes
					for(var i = items_offset/2; s16data[i] ^ LIST_END; i += 4){
						addmesh(new ItemBoxMesh(), s16data[i+0], s16data[i+1], s16data[i+2], "object", "Item box");
					}
				});
				plants.forEach(function(plants_offset){ // piranha plants
					for(var i = plants_offset/2; s16data[i] ^ LIST_END; i += 4){
						addmesh(new PlantMesh(), s16data[i+0], s16data[i+1], s16data[i+2], "object", "Piranha plant");
					}
				});
				trees.forEach(function(trees_offset){ // trees
					for(var i = trees_offset/2; s16data[i] ^ LIST_END; i += 4){
						addmesh(new TreeMesh(), s16data[i+0], s16data[i+1], s16data[i+2], "object", "Tree A");
					}
				});
				bushes.forEach(function(bushes_offset){ // bushes
					for(var i = bushes_offset/2; s16data[i] ^ LIST_END; i += 4){
						addmesh(new PlantMesh(), s16data[i+0], s16data[i+1], s16data[i+2], "object", "Bush");
					}
				});
				
				var object_pane = document.getElementById("objects");
				object_pane.innerHTML = "";
				for(var i = 0; i < meshes.length; i++){
					if(meshes[i][0] == "object"){
						var object_entry = document.createElement("div");
						object_entry.appendChild(document.createTextNode(meshes[i][1]));
						object_entry.index = i;
						object_entry.onmouseenter = function(){
							for(var i = 0; i < meshes.length; i++){
								if(meshes[i][0] == "object"){
									meshes[i][2].material.color.b = 0;
								}
							}
							meshes[this.index][2].material.color.b = 1;
						}
						object_entry.onmouseleave = function(){
							for(var i = 0; i < meshes.length; i++){
								if(meshes[i][0] == "object"){
									meshes[i][2].material.color.b = 0;
								}
							}
						}
						object_entry.onclick = function(){
							for(var i = 0; i < meshes.length; i++){
								if(meshes[i][0] == "object"){
									meshes[i][2].material.color.g = 0;
								}
							}
							meshes[this.index][2].material.color.g = 1;
							mesh_selection = meshes[this.index];
						}
						object_pane.appendChild(object_entry);
					}
				}
			}
			
			// draw single texture to tex canvas
			function drawTexPreview(imgdata, x, y, width, height){
				for(var i = 0; i < imgdata.length && ((i / width)|0) < height; i++){
					var pixel = imgdata[i];
					var r = ((pixel & 0xF800) >> 11) << 3;
					var g = ((pixel & 0x07C0) >>  6) << 3;
					var b = ((pixel & 0x003E) >>  1) << 3;
					var a = pixel & 1;
					tctx.fillStyle = "rgba(" + r + ", " + g + ", " + b + ", " + a + ")";
					tctx.fillRect((i % width) + x, ((i / width)|0) + y, 1, 1);
				}
			}
			
			// draw all course textures to tex canvas
			function drawSeg05Preview(mapId){
				tctx.clearRect(0, 0, 1024, 128);
				var mapdata = maps[mapId];
				var refs_start = mapdata.REFS_START & 0x00FFFFFF;
				console.log(getU32BE(romdata, refs_start));
				var mio0_address;
				var x = 0;
				var y = 0;
				for(var i = 0; mio0_address = getU32BE(romdata, refs_start + i * 16); i++){
					mio0_address = (mio0_address & 0x00FFFFFF) + TEXTURES;
					var tex_size = getU32BE(romdata, refs_start + i * 16 + 8);
					var tdata = Uint8ToUint16ArrayBE(mio0decode(romdata, mio0_address));
					var width = (tex_size == 2048) ? 32 : 64;
					var height = 32;
					drawTexPreview(tdata, x, y, width, height);
					x += width;
					if(x >= 960){
						y += 32;
						x = 0;
					}
				}
			}
			
			//var test_texturedata; // TEST: load first texture from list here, apply to item boxes
			
			function drawMap(mapId){
				drawSeg05Preview(mapId);
				scene = new THREE.Scene();
				meshes = [];
				resetCamera();
				var mapdata = maps[mapId];
				var presets = map_presets[mapId];
				if(presets){
					var seg06 = mio0decode(romdata, mapdata.ASSETS_START);
					drawSeg06(seg06, mapId);
				} else {
					log("Skipped seg06, no preset list for this course available ("+mapId+")")
				}
				var seg04 = mio0decode(romdata, mapdata.MESH_START);
				drawCourseGeometry(seg04);
				loadedname.innerHTML = MAPNAMES[mapId];
			}
			
			function resetCamera(){
				with(camera.position){
					x = 1500;
					y = 500;
					z = 2500;
				}
				with(camera.rotation) x = y = z = 0;
			}
			
			var keyevents = {
				27: function(){ resetCamera()           }, // esc - reset camera position
				87: function(){ camera.translateZ(-10); }, // w - move forward
				65: function(){ camera.translateX(-10); }, // a - pan left
				83: function(){ camera.translateZ( 10); }, // s - move backward
				68: function(){ camera.translateX( 10); }, // d - pan right
				90: function(){ camera.translateY(-10); }, // z - move down
				88: function(){ camera.translateY( 10); }, // x - move up
				40: function(){ camera.rotateX( -0.05); }, // down - rotate down
				38: function(){ camera.rotateX(  0.05); }, // up - rotate up
				37: function(){ camera.rotateY(  0.05); camera.rotation.z = 0;}, // left - rotate left
				39: function(){ camera.rotateY( -0.05); camera.rotation.z = 0;}  // right - rotate right
			};
			
			var keysdown = [];
			document.body.onkeydown = function(e){
				keysdown[e.keyCode] = true;
			}
			document.body.onkeyup = function(e){
				delete keysdown[e.keyCode];
			}
			function animate(){
				camera.rotation.z = 0;
				requestAnimationFrame(animate);
				for(var i in keysdown){
					if(i in keyevents) keyevents[i]();
				}
				// render main view:
				renderer.setClearColor(0x000000, 1);
				renderer.setViewport(0, 0, scenewidth, sceneheight);
				renderer.setScissor(0, 0, scenewidth, sceneheight);
				renderer.render(scene, camera);
				// render bird's eye view:
				renderer.setClearColor(0x111111, 1);
				renderer.setViewport(scenewidth - scenewidth/5 - 10, sceneheight - sceneheight/5 - 10, scenewidth/5, sceneheight/5);
				renderer.setScissor(scenewidth - scenewidth/5 - 10, sceneheight - sceneheight/5 - 10, scenewidth/5, sceneheight/5);
				renderer.render(scene, camera_birdseye);
			}
			init();
			animate();
		</script>
	</body>
</html>